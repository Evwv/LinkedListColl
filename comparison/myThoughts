После сравения разных вариантов коллекций можно подвести некоторые итоги.

Начнем с ArrayList и LinkedList.

Во многих источниках можно встретить вывод : "если ты собираешься вставлять (или удалять) в середину коллекции много элементов,
 то тебе лучше использовать LinkedList. Во всех остальных случаях – ArrayList.". Данный вывод логичен, но в моем случае результаты
 были различны с данным высказыванием. В моем сравнении все операции(вставка в середину, добавление, удаление) ArrayList выполнил быстрее
 своего противника LinkedList.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
ArrayList faster , time work = 16920
Удаление элемента
ArrayList faster , time work = 33841
Вставка элемента в середину
ArrayList faster , time work = 41020

Если говорить о сравнении HashSet, LinkedHashSet, TreeSet для тех же операций, то вывод получается следующий.
Задачу добавления элемента с близкой точностью выполняют HashSet и LinkedListSet , очевидно что TreeSet уступает в скорости
из-за встроенной сортировки значений.

Говоря о удалении элемента и о проверки наличия элемента(брался элемент из середины), утвержающе можно назвать
LinkedHashSet побидетелем по скорости выполнения задачи.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
LinkedHashSet faster , time work = 89217
Удаление последнего элемента
LinkedHashSet faster , time work = 43583
Проерка на содержание элемента в коллекции
LinkedHashSet faster , time work = 48710

Затрагивая виды реализации HashMap, LinkedHashMap, TreeMap, по полученым результатам можно сказать, что
при необходимости добавления элемента лучше использовать HashMap он показал наименьшее время работы по сравнению
с противниками.
При выполнении задачи удаления и проверки на содержания ключа самое быстрое время показывает реализация LinkedHashMap,
что мне кажется странным для проверки на содержание ключа, так как TreeMap сортирует ключи, и при проверки на содержимость
проходит мапу как массив по индексам. Возможно тут приложила руку JVM.

Полученные результаты c количеством элементов в коллекции = 100000 :
Добавление элемента
HashMap faster , time work = 53325
Удаление последнего элемента
LinkedHashMap faster , time work = 36405
Проверка на содержание ключа в середине
LinkedHashMap faster , time work = 33841

Вывод: выбор реализации сторого зависит от поставленной задачи.

